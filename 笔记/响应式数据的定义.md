## ref创建：可以定义基本类型的响应式数据和对象类型的响应式数据

- 作用：定义响应式变量 （基本类型的数据）
- 语法：let xxx = ref（初始值）
- 返回值：一个RefImpl的实例对象，简称ref对象，ref的value是响应式的
- 注意：
  - Js操作数据需要：xxx.value，模板中的不需要.value直接使用就行
  - 对于let name = ref（'张三'），name不是响应式的，但是，name.value是响应式的

## Reactive：只能定义对象类型的响应式数据

使用reactive进行数据的包裹



表面上使用ref实现对象的响应式数据，但是底层还是使用reactive实现的

能够将里面的对象能够设置Proxy类型

reactive定义的对象不能进行整体的修改

想要进行修改的办法：

- 使用逐个修改属性（一个一个进行修改）

- 使用Object.assgin的方法进行修改或者展开运算符

- 使用ref包裹（reactive）进行修改

  ```ts
  import { ref, reactive } from 'vue';
  
  const personRef = ref(reactive({
    name: '张三',
    age: 19
  }));
  
  // ✅ 替换整个对象（通过 ref.value）
  personRef.value = reactive({ name: '王五', age: 20 }); // 响应式仍然有效
  ```

  

## 区别：

- ref创建的对象必须使用.value就行修改（可以使用volar自动添加.value）
- reactive的局限性：reactive重新分配一个对象，会失去响应式（可以使用Object.assign去整体替换）就是直接进行对象的替换不能够实现响应式，不能进行替换 
  想要进行整体的替换，使用Object.assgin进行分配
  就可以实现响应式的数据
- 使用ref就能直接使用value进行修改 value肯定是响应式
- 不能在函数当中使用ref进行更改ref的值



## 开发的时候使用场景：

- 只是需要使用基本类型的响应式数据 必须使用ref
- 需要一个响应式对象，层级不深，都可以使用
- 如果需要一个响应式对象，层级较深，使用reactive（类似表单中数据较多的话 使用reactive更简单）

## toRefs

将响应式对象转换成普通的对象，同时保持所用属性的响应式性质

并且可以新创建的对象的更改，就可以更改原对象的属性值

作用：

- 批量的创建响应式应用
- 解构对象的时候使用，保证就够出来的数据式响应式的

## toRef

从响应式的对象中提取单个属性保证原有的响应式特性

- 保证单个属性的响应式连接
- 用的时候，就直接使用原对象加上想要响应式的数据就行

| 特性                 | `toRef`                            | `toRefs`                             |
| -------------------- | ---------------------------------- | ------------------------------------ |
| **作用**             | 创建单个属性的响应式引用           | 将整个对象的所有属性转换为响应式引用 |
| **参数**             | `toRef(源对象, '属性名')`          | `toRefs(源对象)`                     |
| **返回值**           | 单个 `ref` 对象                    | 包含多个 `ref` 的普通对象            |
| **处理不存在的属性** | 可以创建不存在属性的引用（重命名） | 只会转换已存在的属性                 |

