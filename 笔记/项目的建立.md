## 项目初始化+git管理

## 别名路径联想设置 

就是使用@能直接找到对应的文件

## element UI按需导入配置

## 主题色的定制 安装sass 使用index文件来自定义主题色

## 配置axios 并且进行测试 

？？如果项目不同的业务模块需要的接口基地址不同？
使用axios.create() 方法执行多次，每次执行会生成一个新的实例

```
const http1 = axios.create({baseUrl:})
const http2 = axios.create({baseUrl:})
```

## 路由的创建

- 在view中设置想要展示的页面
- 在router中将view中设置的页面导入，根据编号设置自己的路由 设置 path和component
- 设置的二级路由会和对应的一级路由一起展示出来
- 路由设计的依据
  - 内容的切换方式
- 默认的二级路由的设置方式
  - 将path配置成空 （会跟着以及路由一起展示）

## 设置样式，将特定的设置 放到styles里面 进行引用

## scss文件的自动导入

- 项目中共享的色值一般放在var.scss的文件中，正常的组件的使用，需要先导入scss文件，再使用内部的值，这种情况，我们可以设置自动导入
- 在vite.config,js 中进行自动配置

## Layout页面的搭建

## 图标的引入![image-20250530214050340](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250530214050340.png)

## 吸顶动态展示的作用

- 使用VueUse插件能够获取移动的距离
- 然后使用动态显示器 `:class="{show:y>78}"`
- 来控制这个什么时候进行显示

## 考虑能不能优化 减少发送网络请求的数量![image-20250531084908969](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250531084908969.png)

- 使用pinia进行优化，这样每网络请求只需要触发一次，使用pinia就是集中管理和共享应用程序的状态，将组件组要共享的状态，操作这些业务逻辑进行模块化封装，（用户的状态等等）
  - 集中装填管理
  - 简化组件通信
  - 处理复杂逻辑
  - 状态持久化

- ![image-20250531091014470](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250531091014470.png)
  - 确定页面的形状
  - 分区进行写入
  - 注意：这里的轮播图直接使用组件库里面有的就行

## 面板组件的封装

子组件设置传进来的样式，并且在父组件注册的对应的模块进行展示

- 复用问题 

- 业务维护问题

- 图片上的新鲜好物和人气推荐模块，结构上面相似，只是内容的不同，我们就可以使用组件封装实现复用结构的效果

  - 可以复用的结构写一次，可能发生变化的地方抽象成参数组件(props/插槽)

  - （主标题。。。）

  - 步骤（封装思路）

    - 不做抽象，准备静态结构

    - 抽象可变的部分（复杂的模板就是solt，简单的就是props）

      - 主标题和副标题是纯文本，可以抽象成props传入

        ```ts
        //定义props
        //这个可以将主标题和副标题的内容抽象的从父组件穿过来
        defineProps({
            //主标题
            title : {type : String},
            //副标题
            subTitle : {type : String},
        })
        ```

        

      - 主题内容是复杂的模板，抽象成插槽传入

        - 使用slot 用于传递大片的内容，甚至是复杂的结构
        - 用于实现组件内容的复用和自定义拓展，让组件的使用者可以在组件的预设的位置插入自定义内容，是组件更加灵活和可复用性

      - 新鲜好物使用插槽进行传递，使用接口进行数据的获取

## home-图片懒加载指令实现

- 场景：电商网站的首页通常会很长，用户不一定能访问到页面靠下的图片，这类图片通过懒加载优化手段可以做到只有进入视口区域才发送网络请求

- 原理：图片进入视口才发送请求资源

- 先设置图片是否进入视口的工具，使用VueUse中的工具进行监听

- 当图片进入的时候相应的参数就会发生变化

- 当成功的时候触发对应的函数

- ```ts
  //定义全局指令 自定义指令
  app.directive('img-lazy', {
      mounted(el, binding) { //当img元素所在的父组件挂载完成之后 这个=钩子函数就会执行，接收两个参数
          //el 指令绑定的元素 imgb 直接拿到指定元素的标签
          //binding binding.value 指令等于号后面绑定的表达式的值 就是图片的url
          console.log(el, binding.value)
          useIntersectionObserver(
              el,
              ([{isIntersecting}]) => {
                  console.log(isIntersecting) //用来监听是否进入视口区域 本身就存在的变量
                  if(isIntersecting){
                      //图片进入视口区域
                      el.src = binding.value
                  }
              },
          )
      }
  })
  ```

- 学会自定义指令的时候，懒加载的设置，怎样判断图片进入了视口区域

## 懒加载指令的优化

- 逻辑书写位置不合理
  - 入口文件用来写初始化的文件，不应该包含太多的逻辑代码，
  - 可以用过插件的方法把懒加载指令封装成插件，main.js入口文件只需要负责注册插件就行
  - 在directive中使用设置插件的形式进行封装
  - 后续在路口文件直接进行注册就行

## 重复监听的问题

- useIntersectionObserveu对于元素的监听一直都存在，会造成性能的浪费

## Product产品列表的渲染![image-20250531144911475](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250531144911475.png)

## Home-GoodsItem的封装（纯展示类组件）

- 这个在需要使用跟多的结构卡片就需要这样再次封装一个方法，具有相同的样式，后续直接使用
- 封装思路 ：
  抽象Props参数，传入参数 使用defineProps就是定义的参数

- 进行分类页面的路由配置，能够正确的跳转

## 面包屑导航渲染

- ![image-20250531154347337](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250531154347337.png)

- 获取路由的参数
  - 受限需要在发送请求的地方设置pramas（发送网络请求的时候代表传进去的路由参数加到后面）将我们需要的id传进去，点击就是相当于发送。有参数的url发送的网络请求
  - 使用`import { useRoute } from 'vue-router';` 这个方法能够拿到对应的路由插件，我们直接将对应的网页的参数id传入发送请求的地方
  - 最后将对应的响应式答案传出来就行
  - watchEffect方法
    - 自动追踪依赖并在依赖变化的时候执行回调
    - 立即执行传进来的响应式依赖，并在执行过程中自动追踪所有的响应式依赖，发生变化的时候，回调函数就会执行
    - 和watch不同，不需要指定显示依赖

## 分类轮播图的实现

和首页轮播图的不同就是接口参数不一样，其他的都一样
还是发送请求拿到数据，直接调用轮播图的板子，最后直接放在上面就行

注意：上面设置轮播图的时候请求的数据需要和这里进行区分，我们可以传进去一个参数表示不同的请求的数据

## 一级分类 激活状态的显示和分类列表渲染

就是将点击的设置成点击成功的样式

RouterLink属性组件默认支持激活样式显示的类名，只需要给active-class属性设置对应的类名就行 这个类名就是激活之后的类名（在style中设置样式）

分列表的渲染

使用拿到的数据进行渲染，拿到分列表的数据 直接v-for渲染就行

## 一级分类-路由缓存问题

使用带有参数的路由的时候，从`/user/aaa` -> `/user/bbb` 的时候，相同的组件实例会被重复的使用，因为两个路由都渲染同一个组件，比起销毁了再进行创建，复用会更加高效，
但是组件的生命周期钩子不会被调用

我们的一级分类就会组件实例的复用，导致分类的数据无法更新

解决思路

- 让组件实例不在复用，强制销毁
- 监听路由的变化，变化之后再执行数据更新操作

方法1：

-  给router-view（路由出口的地方）添加key 进行绑定
- 添加key 可以用于强制替换一个组件/元素 而不是复用它，
- 但是组件的所有的都会进行重建，性能的浪费

方法2：使用beforeRouteUpdate导航钩子

- beforeRouteUpdate钩子函数可以在每次路由更新之前执行，在**回调中执行需要数据更新的业务逻辑**即可
- 使用的时候我们需要使用传进去to参数，拿到最新的路径，因为上面的路由参数存在滞后性
- to拿到最新的参数之后，传入最新的id，然后使用最新的id发送网络请求 
- 总结：
  - 路由缓存问题产生的原因是什么
    - 路由参数变化的时候，会复用组件实例，导致页面不能及时的更新
  - 两种方式都可以解决路由的缓存问题，如何选择？
    - 在意性能问题就是用 onbeforeUpdate 但是需要精细化控制
    - 不在意性能问题 使用 key 简单粗暴  

## 一级分类 使用逻辑函数拆分业务

就是将同一个组件中的业务代码哦通过函数进行封装处理，提升代码的可维护性

![image-20250531193418461](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250531193418461.png)

实现步骤：

- 按照业务声明以 “use” 打头的逻辑函数
- 把独立的业务逻辑封装到各个函数的内部
- 函数内部把组件中需要用到的数据或者方法return出去
- 在组件中调用函数把数据或者方法组合来回使用
- 这样做利于维护设置对应的方法

核心思想：

- 逻辑拆分的过程就是一个拆分再组合的过程 这样我们再主体代码中只是使用函数，没有复杂的逻辑代码，这样有助于代码的维护![image-20250531195122896](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250531195122896.png)
- 函数use打头，内部封装逻辑，return组件需要用到的数据和方法给组件进行消费![image-20250531195418135](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250531195418135.png)



## 二级分类 整体认知和路由配置

主要是二级分类的功能和整体的认知
路由的搭建 还是children路由的设置

## 二级分类 面包屑的实现

发送请求的时候使用对应的id发送网络请求，拿到对应的数据
拿到数据之后就渲染到面包屑上就行

## 二级分类 基础列表的渲染

- 实现基础列表的参数（基础参数）
  - 发送网络请求的时候需要使用自己传入参数拿到对应的数据
- 添加额外参数实现 筛选功能 
- 无线加载功能的叠加

## 二级分类 列表功能的实现

### tabs转换功能

点击 tab 切换筛选的条件参数 sortField 重新发送列表请求

![image-20250531205008494](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250531205008494.png)

将能够进行切换的sortField，进行转换，然后得到的值再次发送请求（Tabs之后的对象）进行渲染就行

### 列表无限加载功能

使用elementPlus提供的v-infine-scroll 指令监听是否满足触底条件，满足加载条件时让页数++ 获取下一页的数据，做出新老数据拼接渲染

就是变形状态的分页 监听什么时候滚动底部 进行新的渲染

找到一个判断条件 所有的数据展示完毕
使用`:infinite-scroll-disabled="disabled"`进行判断展示完毕

## 二级分类 定制路由

切换之后，自动切换到顶部

使用vue-router支持scrollBehavior配置项，可以指定路由切换时的滚动位置 （需要手动配置）

![image-20250531213003782](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250531213003782.png)

## 详情页的展示

### 先搭建静态网站

- 设置对应的路由 保证能够正常的跳转

- 注意详情页拿到的对象的数据，要等到数据拿到后才能进行渲染，否则是undefined的时候会报错

  - 使用可选链?. 等到数据加载完成之后才会渲染
  - 使用 v-if 只有有数据了才会进行渲染
  - 不难，就是繁琐，找到对应的字段进行渲染就行

- 当渲染模板的时候遇到对象的多层属性访问可能出现什么问题？

  - `goods.details.pictures`
  - ![image-20250601085654114](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250601085654114.png)

  - 就是上面标注的方法能够解决 就是可能是undefined

### 热榜区域

热榜的结构一致，title和列表的内容不同

先搭建静态的结构

获取静态的渲染数据

获取不同的数据，使用父组件传过来对应的数据，发送网络请求

### 图片预览组件的封装

小图切换大图

- 静态模板
- 将小图绑定事件，记录当前激活下标值
- ![image-20250601095202969](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250601095202969.png)
- 这样就能动态的表示是不是激活的状态

放大镜效果

- 获取鼠标的相对位置
  - 使用useMouseInElement进行获取 位置
- 控制滑块的跟随移动
- 增加距离的判断![image-20250601100655908](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250601100655908.png)

- watch监听xy的变化 根据xy的变化 来更新蒙层的位置
- 找到蒙层移动的距离和xy移动距离之间的关系
- 注意：当鼠标不在目标位置的时候不进行操作
- 图片不能写死，还是得发送请求来获取数据，可以自己写接口发送请求，或者直接definePropos从父组件传入对应的值’

## 封装复杂交互组件通用思路

- 功能拆解
- 寻找核心的实现思路
- 寻找关键技术
- 逐个实现，逐个验证，最后验证

### 图片预览组件的封装逻辑

![image-20250601111249818](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250601111249818.png)

## SKU组件

库存单元 
定义成库存最小可用单位

产出当前用户选择的商品规格，为加入购物车提供商品数据信息

重点看 props决定了当前组件接收什么数据，emit决定了会产出什么数据 就能够使用![image-20250601121934087](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250601121934087.png)

这些选择就是SKU组件

## 通用组件的去全局注册

components目录有很多的通用组件，别的业务中也能够使用，将其设置成全局的组件，直接使用

将component插件进行全局注册 然后使用main.js进行注册

- 在对应的位置设置组件的全局化注册，导入想要进行注册的组件，并且完成配置

- ```ts
  //把component的所用组件及逆行全局化注册
  //通过插件的方式
  import ImageView from './imageView/index.vue'
  import Sku from './XtxSku/index.vue'
  export const componentPlugin = { 
      install(app){
          //对app. de 的组件进行注册
          //app.component('组件的名字‘,组件的配置对象)
          app.component('XtxImageView',ImageView)
          app.component('XtxSku',Sku)
      }
  }
  ```

- 在main.js 当中引用并使用use完成注册

- 后面就不需要再次进行引入，然后直接使用就行

## 登录模块的整体认知和路由配置

主要是表单校验和登录登出业务

### 表单校验功能

前端提前校验可以省去一些错误的请求提交，为后端接口节省压力

直接使用element就有表单校验的功能![image-20250601131635209](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250601131635209.png)

当功能很复杂的时候，通过多个组件各自负责某个小功能，在进行组合合成以一个大功能 常用的方法
每一部分的组件都需要进行绑定，准备表单对象绑定最外层，规则对象绑定中间，双向绑定表单的最内层

#### 自定义校验功能

特殊的校验需求，可以使用自定义的校验规则![image-20250601143924983](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250601143924983.png)

注意：很多的变量内部已经进行定义，直接使用就行

### 整个表单的校验

每个表单域都有自己的校验触发事件，当用户一上来就点击提交怎么办？？

需要在登陆的时候进行全部表单检验

1.用户和密码 只需要使用简单的配置（看文档-复杂的功能通过多个不同的组件拆解）

2.同意协议（自定义规则的形式）传过来validator（） => （rule，val，callback）自定义校验

3.统一校验 通过调用form实例的方法，validate->true

### 基础登录业务的实现

发送登录请求POST的接口，发送请求，返回数据

使用插件对登陆成功展示提示，并且使用router完成跳转

最后使用拦截器对错误进行统一的处理即可

### Pinia管理用户的数据

用户数据在很多的组件中有可能进行共享，共享的数据使用pinia管理更加方便

！！！和组件的所有操作（state+action）放到pinia当中，组件只负责触发action函数！！！

组件触发action函数，内部接口获取数据，存储用户的信息

### Pinia用户数据持久化

- 用户的数据有一个关键词是Token（用来表示当前用户是否已经登录）而Token持续一段事件才会过期
- Pinia存储基于内存，刷新就会丢失，为了保证登陆状态就要做到刷新不丢失，需要配合持久化进行存储
- 需要保证token不丢失
- 操作state的时候会将用户数据存储在localStoreage中存储，刷新的时候会从localStorage中获取
- 使用pinia的插件进行配置
  - 安装插件包
  - pinia注册插件
  - 需要持久化的store进行配置
  - 这样设置state的时候就会自动的把数据同步给localStorage 获取state数据的时候会优先从localStorage取

## 登录和非登录的模板适配

多模板适配

有几个需要进行适配的模板就准备几个template，通过条件渲染进行控制即可![image-20250601164146059](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250601164146059.png)

## 请求拦截器携带token

Token是用户表示，需要在很多接口中都需要携带Token才能正确获取数据

为了统一的进行配置采取请求拦截器携带Token的方案

设置axios请求数据，将Token注入到header中，格式按照后端要求的格式进行拼接

原因：很多的接口需要健全，需要使用token 直接发送请求的时候拿到特定的数据

## 退出登录的业务的实现

直接在store那里定义一个函数将token进行删除操作
在将这个函数调出来，

退出登录的时候直接进行使用就行，将token进行删除

## token失效作用

Token的有效性可以保持一段的事件，如果用户一段时间不做操作，Token就会失效，使用失效的token再去请求一些接口，会返回401，这是需要我们做额外的处理

在axios拦截器中的失败回调拦截401（统一处理）

清除过期的用户信息，并且跳转到登录页

## 购物车的实现

- 整个购物车的实现分成两大块，本地购物车和接口购物车操作
- 由于购物车的特殊性，采取Pinia管理购物车列表数据并添加持久化缓存

![image-20250601203544002](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250601203544002.png)

根据图上的逻辑进行操作就行 将购物车的**完整**信息添加到Pinia当中

## 头部购物车的列表渲染

接收数据进行渲染就行

还是在组件中进行编写，然后直接使用对应的注册名字放进主页进行

## 头部购物车删除实现

在store中定义删除action函数 实现删除的逻辑

组件中调用action并传递skuId找到相同的编号（findIndex）进行删除

统一的管理状态并进行修改

## 计算的实现

使用computed进行实现就行，在store的地方进行计算，导出就行

## 购物车的相关实现

先用静态模板的搭建，然后使用对应的store中的值进行渲染就行

- 单选功能
  - 单选框的状态和pinia中的store中的状态保持同步
  - 注意：v-model双向绑定指令不适合进行命令式的操作（因为后续还需要调用接口），所以把v-model回退到一般模式，就是 :model-value+@change的配合实现
  - v-model就是model-value+@change的语法糖
  - 这里我们需要对每一步进行精细的控制，控制是否选中，所以我们要拆开计算
  - 当我们需要传入多个参数的时候可以在标签当中使用箭头函数的形式将参数传入![image-20250601215402229](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250601215402229.png)

- 全选功能的实现
  - ![image-20250601220853034](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250601220853034.png)
  - 在store中设置参数表示是否全选，来表示是否是全选
  - 在index当中定义函数来表示，是否触发全选操作
  - 注意：element插件选中状态改变的时候触发的函数会自动将后来的状态闯入回调的函数
- 接口购物车的实现
  - 在action当中做登录状态的分支判断，补充登陆状态下的接口操作逻辑就行
  - 调用加入购物车的接口函数
  - 调用获取购物车列表的接口
  - 用接口购物车列表进行覆盖本地购物车列表
- 删除购物车的实现
  - 调用接口删除购物车接口
  - 调用获取购物车列表
  - 用接口购物车列表覆盖本地购物车列表
  - 注意：computed返回的是ref对象
  - 根据上面的接口写函数，进行操作就行
- 退出登录，删除购物车列表
  - 推出的时候将cart的数组设置成空数组就行，
  - 就是多个store的数据共享和方法调用
  - 多模块方法调用的时候，要在方法里面进行调用，防止出现问题
- 合并本地购物车到服务器
  - 用户非登录的购物车的操作，服务器不知道
  - 用户登陆的时候，把本地的购物车和服务端的购物车进行合并
  - 登陆时调用合并购物车接口，获取最新的购物车列表，更新即可
  - 注意：发送请求的时候记得使用await形成异步函数

## 结算模块

### 路由配置

路由配置

- 准备对应的路由组件，配置路由关系，配置路由跳转

基础的数据渲染

- 准备接口 获取数据 渲染默认地址和商品列表以及统计数据
- 拿到默认地址的筛选逻辑就行

### 地址切换交互实现

- 就是经常遇到的“tab切换类”

  - 点击记录的一个当前激活地址对象activeAddress，点击哪个地址就是将哪个地址对象记录下来，
  - 通过动态类名 :class控制激活样式类型active是否存在，
    判断条件就是 激活对象id === 当前项id![image-20250602102432545](C:\Users\Lenovo\Desktop\Vue\笔记\image-20250602102432545.png)

  - 动态的添加class 动态的添加样式 前提是我们必须拿到对应的activeAddress
  - tab交互页
  - 把点击的激活项使用回调函数记录下来，然后使用动态样式进行调整
  - 主要是学会如何进行动态的类名控制

## 生成订单功能实现

- 调用接口生成订单id 携带id跳转到支付页面
  - 准备祝福路由
  - 封装生成订单的接口
  - 点击按钮调用接口 ，生成订单id 携带id完成路由的
- 调用购物车列表接口，更新购物车的状态跳转
- 就是生成订单id 带着id跳转到对应支付页面就行 
- 更新购物车

## 支付模块的基础数据的渲染

- 封装获取订单详情的接口
- 获取关键数据进行渲染就行

## 实现支付功能

![image-20250602132540259](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250602132540259.png)

主要是前面的过程 

- 拼接支付的地址 进行正确的支付操作
- 支付成功之后就return出来 返回到原来的地址

## 支付结果的展示

- 配置paycallback的路由（命名当时要规范一点）
- 根据支付的结果配置支付的状态
- 获取订单数据渲染支付信息

## 支付模块的倒计时的操作

实现逻辑函数 注意先看数据里面有没有相应的数据类型，能不能直接使用

- 确实基础的架子，参数
- 编写函数的核心逻辑 实现格式化什么的
- 实现小的优化 将函数更加完善 

## 会员中心的实现

### 整体思路梳理和路由配置

- 个人中心的静态模板

- 绑定个人中心的二级路由
- 准备个人中心和我的订单的三级路由的跳转
- 在个人中心配置三级路由

### 个人中心的信息渲染

- 个人中心使用Pinia中的数据
- 猜你喜欢使用接口获取

### 订单的基础列表渲染

- 定义接口
- 直接进行数据的调用 渲染

### tab切换的实现

切换Tab的时候切换orderState参数，再次发起请求获取订单列表数据

![image-20250602161324930](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250602161324930.png)

### 分页功能的实现

- 使用列表数据生成分页（页数 = 总条数/每页条数）这些都是后端传来的数据
  ![image-20250602162149795](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250602162149795.png)
- 切换分页修改page参数，再次获取订单列表数据![image-20250602163712654](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250602163712654.png)
- 分页逻辑的事件就是不断拿到对应的数据
- 发送请求，进行更新

### 细节优化

- 当路由是member的时候我们希望直接显示user中的内容
  - 当我们想要二级路由的默认直接显示三级路由的时候，我们可以将对应的默认的三级路由的路由设置成空
  - 记得全部使用过三级路由的地方设置一下
- 根据接口文档给到的状态码和中文的对应的关系进行适配
  - 对状态码进行适配![image-20250602170816624](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250602170816624.png)

## SKU组件详解

sku组件是为了让用户能够选择商品的规格，从而提交购物车，选择的过程中，组件的状态要进行更新，组件还要提示用户当前规格是否禁用，每次选择产出对应的SKU组件

有些情况下存在禁用的情况，我们需要进行特殊的设置（规格的禁用）

![image-20250602183758383](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250602183758383.png)

注意更新禁用的状态

可以对复杂的组件进行拆分

### 实现激活的功能

监听当前的元素的状态，将状态设置成相反的状态

其他的元素都设置成未选中的状态（排他）

### 点击规划更新禁用状态

生成**有效路径字典**

根据库存的内内容进行设置，观察库存的内容

核心原理：

​	当前的规格的SKU，或者组合起来的SKU，在SKUs数组中对应的库存是0时，当前的规格就会被禁用，生成路径字典是为了协助和简化这个匹配的过程

![image-20250602192343545](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250602192343545.png)

找到能匹配的东西，进行匹配来看是否可以进行选择

根据进行匹配的数据进行禁用，得到路径字典就可以使用，匹配不上就禁用

就是这样救就能简单的根据这个进行匹配，没有的东西就需要进行禁用

1. 根据库存字段生成有效的Sku数组
2. 根据有效的Sku数组使用powerSet算法实现得到所有的子集
3. 根据子集生成路径字典对象

```ts
//生成有效的字典对象
const getPathMap = (goods) => {
    const pathMap = {}
    //1.根据Sku字段生成有效的sku数组
    const effectiveSkus = goods.skus.filter(sku => sku.inventory > 0)
    //2.根据上面的的得到的有效的sku算法（子集算法） [1,2] => [[1] [2] [1,2]] 进行拆分和组合
    effectiveSkus.forEach(sku => {
        //2.1获取匹配的valueName组成的数组
        const selectedValArr = sku.specs.map(val => val.valueName)
        //2.2使用算法获取子集
        const valueArrPowerSet = powerSet(selectedValArr)
        //3.将得到的子集生成最终的路径字典对象
        valueArrPowerSet.forEach(arr => {
            //初始化key 采取join -> 字符串 作为对象的key
            const key = arr.join('-')
            //如果已经存在当前key ，那就往数组中直接添加skuId 
            //如果不存在就直接做赋值
            if(pathMap[key]){
                pathMap[key].push(sku.id)
            }else{
                pathMap[key] = [sku.id]
            }
        })
    })
    return pathMap
}
```

#### 初始化规格的禁用

遍历每一个规格的对象，使用name字段作为key去路径字典pathMap中做匹配，匹配不上就禁用

使用name字段！！进行匹配，禁用通过添加动态类名进行禁用

通过动态的添加disable进行禁用操作

#### 点击时组合禁用更新

点击规格的时候

1. 按照顺序得到规格中的项的数组 ["蓝色"，"20cm",undefined]
2. 遍历每一个规格
   1. 把name字段的值填充到对应的位置
   2. 过滤到undefined项使用join的方法形成一个有效的key
   3. 使用key去pathMap中进行匹配，匹配不上，就将当前的项禁用

### 产出有效的Sku

是否先择了所有的undefined

判断是否还存在undefined就行

如何获取当前的Sku’信息对象？

把已经选择项的拼接为路径字典的key，去路径字典中找即可

尝试改造sku组将