# watchEffect

立即运行一个函数，同时响应式的追踪其依赖，并在依赖进行更改的时候执行

和watch的对比

- 都能监听响应式数据的变化，不同的是监听数据变化的方式不同
- watch：要明确的指出监视的数据
- watchEffect：不用明确的指出监听的数据，（函数中用到的数据，会自动的监听）
- watchEffect拿不到对应的旧值
- watch监听特定的数据，监听的更加精确，但是watchEffect监听的依赖发生变化的时候总会重新执行，可能触发多余的回调
- 如果你需要侦听一个嵌套数据结构中的**几个**属性，`watchEffect()` 可能会比深度侦听器更有效，因为它将只跟踪回调中被使用到的属性，而不是递归地跟踪所有的属性。
- 能够追踪所有听到的数据源，自动追踪所有访问响应式数据，更加的简洁
  但是watch只追踪明确侦听的数据源，不会追踪任何回调中访问到的数据

## watchEffect的参数和返回值

### 回调函数参数

使用onInvalidate函数进行监听，用来在依赖变化的时候清理副作用（定时器，网络请求

返回值也是一个暂停的函数，直接调用就能停止监听

## flush设置执行的时机

per post sync 和watch相同

## watchEffect的依赖收集

会在每次回调执行的时候重新收集调用的数据

## 可以直接监听computed处理后的数据

## 副作用的清理

- 我们可能会在侦听器中执行副作用，例如异步请求
- 当我们的响应值进行更新的时候，但是我们的请求是以旧的响应值发送的，这时我们想要取消之前发送的请求，就使用 onWatcherCleannup（Vue3.5+）来进行清除
- 这个函数必须在同步执行期间进行调用，但是不能在异步函数await之后调用它
- 作为替代，onCleanup作为第三个参数传递给监听器回调

## 停止监听器

在`setup`或者`script setup`中同步创建的监听器，会自动的绑定到宿主组件的实例上，并且会在宿主卸载组件时自动的停止，

注意：：：监听器必须使用同步语句进行创建。如果使用异步回调进行创建，不会进行绑定，必须手动的停止，以防止内存泄漏

